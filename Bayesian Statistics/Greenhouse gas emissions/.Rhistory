# Count the number of iterations
if (iter %% 1000 == 0) {
cat(paste0("Iteration: ", iter, " of ", MHIter, ". Elapsed time is ", Sys.time(), ".\n"))
}
# Graphical representation
cat(paste0("Acceptance rate = ", naccept/MHIter, "\n"))
par(mfrow = c(1, 3))
plot(output)
acf(output)
hist(output)
# Innovation size for the uniform RW proposal
a <- 8 # can take values a = 0.6, 6 or 60
output <- numeric(MHIter-burnin) # store the chain values
naccept <- 0 # count the number of iterations that we accept the proposed value
theta   <- 0 # initial value
output[1] <- theta
# MH algorithm
for (iter in 2:MHIter) {
# Symmetric uniform random walk proposal: \theta^star \sim U(\theta - a,\theta + a)
proposal <- theta + runif(1, -a, a)
# Posterior ratio between the posterior evaluated in proposal and in old value
# Posterior is a standard normal distribution
# Not consider the proposal ratio since it is equal to 1
aprob  <- dnorm(proposal)/dnorm(theta)
# Another way of providing the posterior ratio
#aprob1 <- exp(-0.5*(proposal^2 - theta^2))
# Acceptance probability as the min(1, posterior ratio)
aprob <- min(1, aprob)
# Generate random numbers from a Unif(0,1)
u <- runif(1)
# Accept the proposed value
if (u < aprob) {
theta   <- proposal
naccept <- naccept + 1 # count how many times we accept
}
if (iter > burnin) {
output[iter-burnin] <- theta # store the MH chain
}
# Count the number of iterations
if (iter %% 1000 == 0) {
cat(paste0("Iteration: ", iter, " of ", MHIter, ". Elapsed time is ", Sys.time(), ".\n"))
}
# Graphical representation
cat(paste0("Acceptance rate = ", naccept/MHIter, "\n"))
par(mfrow = c(1, 3))
plot(output)
acf(output)
hist(output)
# Set the seed
set.seed(100)
# Number of Metropolis-Hastings (MH) iterations
MHIter <- 10000
# Number of burn-in iterations
burnin <- 1000
# Standard deviation for the normal independence proposal
a_Independ <- 5 # can take values a = 1, 2, 3, 6, 20 or 100
# Standard deviation for the normal RW proposal
a_RWNormal <- 1 # can take values a = 0.1, 0.5, 1, 4, 10 or 100
output_Independ <- numeric(MHIter - burnin) # store the chain values
output_RWNormal <- numeric(MHIter - burnin) # store the chain values
naccept_Indep <- 0 # count the number of iterations that we accept the proposed value
naccept_RWNor <- 0 # count the number of iterations that we accept the proposed value
theta_Indep <- 0 # initial value for Independence Chain
theta_RWNor <- 0 # initial value for Normal RW Chain
output_Independ[1] <- theta_Indep
output_RWNormal[1] <- theta_RWNor
for (iter in 1:MHIter) {
## Independence chain M-H
# Draw a candidate for independence chain ~ N(0, a_Indep^2)
thetaCand_Indep <- a_Independ*rnorm(1)
# Compute the ratio
ratio_Indep <- exp(0.5*(abs(theta_Indep) - abs(thetaCand_Indep) +
(thetaCand_Indep/a_Independ)^2 - (theta_Indep/a_Independ)^2))
# Acceptance probability as the min(1, posterior ratio)
aprob_Indep <- min(ratio_Indep, 1)
# Generate random numbers from a Unif(0,1)
u <- runif(1)
# Accept the proposed value
if (u < aprob_Indep) {
theta_Indep <- thetaCand_Indep
naccept_Indep <- naccept_Indep + 1
}
## Random walk chain M-H
# Draw a candidate for Normal RW chain
thetaCand_RW <- theta_RWNor + a_RWNormal*rnorm(1)
# Compute the ratio
ratio_RW <- exp(0.5*(abs(theta_RWNor) - abs(thetaCand_RW)))
# Acceptance probability as the min(1, posterior ratio)
aprob_RW <- min(ratio_RW, 1)
# Generate random numbers from a Unif(0,1)
u <- runif(1)
# Accept the proposed value
if (u < aprob_RW) {
theta_RWNor <- thetaCand_RW
naccept_RWNor <- naccept_RWNor + 1
}
if (iter > burnin) {
output_Independ[iter - burnin] <- theta_Indep # store the MH chain
output_RWNormal[iter - burnin] <- theta_RWNor # store the MH chain
}
cat("Independence chain M-H --- Proportion of accepted candidate draws is equal to ",
round(naccept_Indep/(MHIter-burnin), 5), "\n")
cat("Random walk chain M-H  --- Proportion of accepted candidate draws is equal to ",
round(naccept_RWNor/(MHIter-burnin), 5), "\n")
fs <- 22
plot(output_Independ, type = "l", xlab = "", ylab = "",
main = paste("Independence M-H Chain, when d = ", a_Independ))
par(las = 1, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
title(main = paste("Independence M-H Chain, when d = ", a_Independ), line = 2, cex.main = 1.5)
grid()
plot(acf(output_Independ), xlab = "", ylab = "",
main = paste("Independence M-H Autocorr, when d = ", a_Independ))
title(main = paste("Independence M-H Autocorr, when d = ", a_Independ), line = 2, cex.main = 1.5)
par(las = 1, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
grid()
fs <- 22
plot(output_RWNormal, type="l")
title(paste("Random walk M-H Chain, when d =", a_RWNormal))
par(font.size=fs)
par(las = 1, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
autocorr.plot(output_RWNormal)
library(car)
autocorr.plot(output_RWNormal)
acf(output_RWNormal)
title(paste("Random walk M-H Autocorr, when d =", a_RWNormal))
plot(output_RWNormal, type="l")
title(paste("Random walk M-H Chain, when d =", a_RWNormal))
par(las = 1, cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
acf(output_RWNormal, title = (paste("Random walk M-H Autocorr, when d =", a_RWNormal)))
par(font.size=fs)
var(output_Independ)
# Metropolis-within-Gibbs sampling Hastings algorithm with RW normal proposal
# Closed form for lambda and not closed form for alpha
set.seed(100)
# Number of MH iterations
MHIter <- 40000
# You can try different values of the innovation
innov <- 0.8373 #sigma_alpha is the variance of the Normal RW proposal # best value = 0.9
n <- 50 # number of observations
# Information about the data
xbar <- 0.62 # sample mean based on the data --- mean(data)
sbar <- 0.4 # sample standard deviation based on the data --- sd(data)
xgbar <- 0.46 # sample geometric mean = sqrt(1/n) * prod(data)
# Prior elicitation/information
output <- matrix(0, nrow = MHIter, ncol = 2)
a <- 2; b <- 1 # are the hyperparameters of the Gamma prior for alpha ~ Ga(a,b)
c <- 3; d <- 1 # are the hyperparameters of the Gamma prior for gamma ~ Ga(c,d)
# Step 1 is set the counter = 1 and set the initial values of the chain
alpha <- (xbar/sbar)^2 # alpha^(0) = xbar^2/sbar^2
lambda <- xbar/(sbar)^2 # lambda^(0) = xbar/sbar^2
naccept <- 0 # initialize the counter of how many times I am accepting the proposed value
# MCMC algorithm
for (i in 1:MHIter) {
## Step 2 is the posterior distribution for lambda, which was in closed form
# lambda ~ Ga(c + n*alpha, d + n*xbar)
lambda <- rgamma(1, shape = c + n*alpha, rate = d + n*xbar) # Update of lambda
## Step 3 generate a proposed value for alpha* from a Normal RW
proposal <- rnorm(1, mean = alpha, sd = innov) # normal RW proposal
# Telling us to use only positive values of alpha since alpha is a
# positive scalar
if (proposal > 0) {
# Step 4 Evaluate the acceptance rate
accrate <- (proposal/alpha)^(a-1) * (gamma(alpha)/gamma(proposal))^n *
exp((b-n*log(lambda)-n*log(xgbar))*(alpha-proposal))
# Evaluate the logarithm transformation of the acceptance rate to
# solve numerical issues
logaprob <- (a - 1) * log(proposal/alpha) + n * log(gamma(alpha)/gamma(proposal)) +
(b + n * log(xgbar) + n * log(lambda)) * (proposal - alpha)
# Generate a random number from a uniform btw 0 and 1
u <- runif(1)
# Step 5 - Am I accepting the proposed value or not?
if (log(u) < logaprob) {
alpha <- proposal # accept the proposed value
naccept <- naccept + 1 # update the counter of the acceptance rate
}
output[i,1] <- alpha
output[i,2] <- lambda
}
## Graphical representation
cat("Acceptance rate = ", naccept/MHIter, "\n")
SigmaA <- 2.38 * sd(output[,1])
SigmaA
# Figure for alpha
plot(output[,1], type = "l", main = 'Chain for \alpha -- no burn-in')
# Figure for alpha
plot(output[,1], type = "l", main = "Chain for alpha -- no burn-in", xlab = "Iterations", ylab = "Alpha", cex.main = fs)
fs <- 22
# Figure for alpha
plot(output[,1], type = "l", main = "Chain for alpha -- no burn-in", xlab = "Iterations", ylab = "Alpha", cex.main = fs)
acf(output[,1], main = "Autocorrelation for alpha -- no burn-in", cex.main = fs)
# Figure for alpha
plot(output[,1], type = "l", main = "Chain for alpha -- no burn-in", xlab = "Iterations", ylab = "Alpha")
acf(output[,1], main = "Autocorrelation for alpha -- no burn-in", cex.main = fs)
# Figure for lambda
plot(output[,2], type = "l", main = "Chain for lambda -- no burn-in", xlab = "Iterations", ylab = "Lambda")
acf(output[,2], main = "Autocorrelation for lambda -- no burn-in", cex.main = fs)
# Figure for alpha with burn-in and thinning
thin <- 20
burnin <- 5001
plot(output[burnin:thin:nrow(output),1], type = "l", main = "Chain for alpha -- burn-in + thinning", xlab = "Iterations", ylab = "Alpha")
acf(output[burnin:thin:nrow(output),1], main = "Autocorrelation for alpha -- burn-in + thinning")
# Figure for lambda with burn-in and thinning
plot(output[burnin:thin:nrow(output),2], type = "l", main = "Chain for lambda -- burn-in + thinning", xlab = "Iterations", ylab = "Lambda")
acf(output[burnin:thin:nrow(output),2], main = "Autocorrelation for lambda -- burn-in + thinning")
# Lecture 17
library(mvtnorm)  # for the Gamma distribution function rgamma()
# Set the seed
set.seed(100)
# Number of MH iterations
MHIter <- 40000
# Number of MH iterations
MHIter <- 40000
# You can try different values of the hyperparameters for independence proposal
A <- 4; B <- 1/2
n <- 50 # number of observations
# Information about the data
xbar  <- 0.62 # sample mean based on the data --- mean(data)
sbar  <- 0.4  # sample standard deviation based on the data --- sd(data)
xgbar <- 0.46 # sample geometric mean = \sqrt{1/n}{\prod_{i=1}^n x_i} --- sqrt(1/n){prod(data)}
# Prior elicitation/information
output <- matrix(0, nrow = MHIter, ncol = 2)
a <- 2; b <- 1 # are the hyperparameters of the Gamma prior for alpha ~ Ga(a,b)
c <- 3; d <- 1 # are the hyperparameters of the Gamma prior for gamma ~ Ga(c,d)
# Step 1 is set the counter = 1 and set the initial values of the chain
alpha  <- (xbar/sbar)^2 # alpha^(0) = xbar^2/sbar^2
lambda <- xbar/(sbar)^2 # lambda^(0) = xbar/sbar^2
naccept <- 0 # initialize the counter of how many times I am accepting the proposed value
## MCMC algorithm
for (i in 1:MHIter) {
## Step 2 is the posterior distribution for lambda, which was in closed form
# lambda ~ Ga(c + n*alpha, d + n*xbar)
lambda   <- rgamma(n = 1, shape = c + n*alpha, rate = d + n*xbar) # Update of lambda
## Step 3 generate a proposed value for alpha* from a Normal RW
proposal <- rgamma(n = 1, shape = A, scale = 1/B) # normal RW proposal
# Telling us to use only positive values of alpha since alpha is a
# positive scalar
# Step 4 Evaluate the acceptance rate
accrate <- (proposal/alpha)^(a-1) *(gamma(alpha)/gamma(proposal))^n *
exp((b-n*log(lambda)-n*log(xgbar))*(alpha-proposal))
# Evaluate the logarithm transformation of the acceptance rate to
# solve numerical issues
logaprob <- (a - 1) * log(proposal/alpha) + n * log(gamma(alpha)/gamma(proposal)) +
(b + n * log(xgbar) + n * log(lambda)) * (proposal - alpha)
logaprob <- logaprob + dgamma(alpha, shape = A, scale = 1/B, log = TRUE) -
dgamma(proposal, shape = A, scale = 1/B, log = TRUE)
# Generate a random number from a uniform btw 0 and 1
u <- runif(n = 1, min = 0, max = 1)
# Step 5 - Am I accepting the proposed value or not?
if (log(u) < logaprob) {
alpha   <- proposal # accept the proposed value
naccept <- naccept + 1 # update the counter of the acceptance rate
}
output[i,1] <- alpha
output[i,2] <- lambda
}
# Graphical representation
cat(paste("Acceptance rate = ", naccept/MHIter, "\n"))
fs <- 22
# Figure for alpha
plot(output[,1], main="Chain for alpha -- no burn-in", xlab="Iteration", ylab="Alpha")
acf(output[,1], main="Autocorrelation for alpha -- no burn-in", lag.max=20, ylim=c(-0.2, 1))
par(mar=c(5, 4, 4, 2) + 0.1)
# Figure for lambda
plot(output[,2], main="Chain for lambda -- no burn-in", xlab="Iteration", ylab="Lambda")
acf(output[,2], main="Autocorrelation for lambda -- no burn-in", lag.max=20, ylim=c(-0.2, 1))
par(mar=c(5, 4, 4, 2) + 0.1)
# Figure for alpha with burn-in and thinning
thin <- 20
burnin <- 5001
plot(output[burnin:thin:nrow(output),1], main="Chain for alpha -- burn-in + thinning", xlab="Iteration", ylab="Alpha")
acf(output[burnin:thin:nrow(output),1], main="Autocorrelation for alpha -- burn-in + thinning", lag.max=20, ylim=c(-0.2, 1))
par(mar=c(5, 4, 4, 2) + 0.1)
# Figure for lambda with burn-in and thinning
plot(output[burnin:thin:nrow(output),2], main="Chain for lambda -- burn-in + thinning", xlab="Iteration", ylab="Lambda")
acf(output[burnin:thin:nrow(output),2], main="Autocorrelation for lambda -- burn-in + thinning", lag.max=20, ylim=c(-0.2, 1))
par(mar=c(5, 4, 4, 2) + 0.1)
setwd("~/GitHub/Projects/Bayesian Statistics/Greenhouse gas emissions")
data <- read_excel("data.xlsx", sheet = 'Data')
library(tidyverse)
library(readxl)
library(lubridate)
library(zoo)
library(xts)
library(dplyr)
library(data.table)
data <- read_excel("data.xlsx", sheet = 'Data')
str(data)
data$Bovine_heads <- as.numeric(data$Bovine_heads)
str(data)
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Share_of _land_under_permanent_crops <- as.numeric(data$_land_under_permanent_crops)
data$Share_of _land_under_permanent_crops <- as.numeric(data$Share_of _land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
str(data)
View(data)
data <- read_excel("data.xlsx", sheet = 'Data')
str(data)
data$Bovine_heads <- as.numeric(data$Bovine_heads)
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
str(data)
install.packages("imputeTS")
library(imputeTS)
#Data imputation
x <- na_interpolation(data$Rail_tracks_KM, option = 'linear')
str(data)
#Data imputation
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'linear')
rownames(data) <- data$Year
library(ggplot2)
data %>% ggplot(aes(Time, Rail_tracks_KM)) + geom_line()
data %>% ggplot(aes(Year, Rail_tracks_KM)) + geom_line()
summary(data$Rail_tracks_KM)
str(data$Rail_tracks_KM)
data <- read_excel("data.xlsx", sheet = 'Data')
data$Bovine_heads <- as.numeric(data$Bovine_heads)
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
#Data imputation
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'spline')
data %>% ggplot(aes(Year, Rail_tracks_KM)) + geom_line()
str(data$Rail_tracks_KM)
data <- read_excel("data.xlsx", sheet = 'Data')
data$Bovine_heads <- as.numeric(data$Bovine_heads)
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'stine')
data %>% ggplot(aes(Year, Rail_tracks_KM)) + geom_line()
data <- read_excel("data.xlsx", sheet = 'Data')
data$Bovine_heads <- as.numeric(data$Bovine_heads)
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
#Data imputation
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'spline')
data %>% ggplot(aes(Year, Rail_tracks_KM)) + geom_line()
str(data)
data %>% ggplot(aes(Year, Total_freight_loaded_and_unloaded)) + geom_line()
data$Total_freight_loaded_and_unloaded <- na_interpolation(data$Total_freight_loaded_and_unloaded, option = 'spline')
data %>% ggplot(aes(Year, Total_freight_loaded_and_unloaded)) + geom_line()
data <- read_excel("data.xlsx", sheet = 'Data')
#Turn character features to numeric
data$Bovine_heads <- as.numeric(data$Bovine_heads)
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
str(data$Rail_tracks_KM)
#Data imputation
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'spline')
data$Total_freight_loaded_and_unloaded <- na_interpolation(data$Total_freight_loaded_and_unloaded, option = 'line')
data$Total_freight_loaded_and_unloaded <- na_interpolation(data$Total_freight_loaded_and_unloaded, option = 'linear')
data %>% ggplot(aes(Year, Total_freight_loaded_and_unloaded)) + geom_line()
str(data)
summary(data)
#Standard
par(mfrow = c(1, 4))
data %>% ggplot(aes(Year, net_greenhouse_pc)) + geom_line()
data %>% ggplot(aes(Year, environmental_taxes)) + geom_line()
data %>% ggplot(aes(Year, `GDP pc`)) + geom_line()
data %>% ggplot(aes(Year, industrial_production)) + geom_line()
#Standard
par(mfrow = c(2, 2))
data %>% ggplot(aes(Year, net_greenhouse_pc)) + geom_line()
data %>% ggplot(aes(Year, environmental_taxes)) + geom_line()
data %>% ggplot(aes(Year, `GDP pc`)) + geom_line()
data %>% ggplot(aes(Year, industrial_production)) + geom_line()
#Standard
par(mfrow = c(2, 2))
plot(x = data$Year, y = data$net_greenhouse_pc)
#Standard
par(mfrow = c(2, 2))
plot(x = data$Year, y = data$net_greenhouse_pc, type ="l" )
plot(x = data$Year, y = data$environmental_taxes, type ="l")
plot(x = data$Year, y = data$`GDP pc`, type ="l")
plot(x = data$Year, y = data$industrial_production, type ="l")
str(data)
par(mfrow = c(2, 2))
plot(x = data$Year, y = data$energy_imp_dep, type = "l" )
plot(x = data$Year, y = data$naturalgas_imports, type = "l")
plot(x = data$Year, y = data$oil_imports, type = "l")
plot(x = data$Year, y = data$total_energy_supply, type = "l")
par(mfrow = c(2, 2))
plot(x = data$Year, y = data$gross_electricity_production, type = "l" )
plot(x = data$Year, y = data$hydro_capacity, type = "l")
plot(x = data$Year, y = data$geothermal_capacity, type = "l")
plot(x = data$Year, y = data$wind_capacity, type = "l")
par(mfrow = c(2, 2))
plot(x = data$Year, y = data$solar_capacity, type = "l" )
plot(x = data$Year, y = data$biofuels_capacity, type = "l")
plot(x = data$Year, y = data$biogas_capacity, type = "l")
plot(x = data$Year, y = data$waste_capacity, type = "l")
par(mfrow = c(2, 2))
plot(x = data$Year, y = data$Bovine_heads, type = "l" )
plot(x = data$Year, y = data$Pigs_heads, type = "l")
plot(x = data$Year, y = data$Share_of_land_under_permanent_crops, type = "l")
plot(x = data$Year, y = data$Area_harvested_Rice, type = "l")
View(data)
str(data)
par(mfrow = c(2, 2))
plot(x = data$Year, y = data$Fertilizer_used_per_area_of_cropland, type = "l" )
plot(x = data$Year, y = data$Share_in_land_area_Forest_Land, type = "l")
plot(x = data$Year, y = data$Rail_tracks_KM, type = "l")
plot(x = data$Year, y = data$Length_of_motorways, type = "l")
par(mfrow = c(1, 2))
plot(x = data$Year, y = data$Number_of_motorcycle, type = "l" )
plot(x = data$Year, y = data$Total_freight_loaded_and_unloaded, type = "l")
data <- data %>% mutate(livestock_heads = Pigs_heads + Bovine_heads)
str(data)
data <- data %>%
mutate(livestock_heads = Pigs_heads + Bovine_heads) %>%
select(!c(Pigs_heads, Bovine_heads))
str(data)
data <- data %>%
mutate(res_capacity = hydro_capacity + geothermal_capacity +
wind_capacity + solar_capacity + biofuels_capacity +
biogas_capacity + waste_capacity) %>%
select(!c(hydro_capacity, geothermal_capacity,
wind_capacity, solar_capacity, biofuels_capacity,
biogas_capacity, waste_capacity))
str(data)
par(mfrow = c(1, 2))
plot(x = data$Year, y = data$livestock_heads, type = "l" )
plot(x = data$Year, y = data$res_capacity, type = "l")
install.packages('tseries')
#ADF test
adf.test(data$net_greenhouse_pc)
#ADF test
library(tseries)
#ADF test
#H0: time series is not stationary
adf.test(data$net_greenhouse_pc)
data <- data %>% mutate(net_greenhouse_pc = scale(net_greenhouse_pc))
str(data)
View(data)
plot(x = data$Year, y = data$net_greenhouse_pc, type = "l" )
data <- read_excel("data.xlsx", sheet = 'Data')
data$Bovine_heads <- as.numeric(data$Bovine_heads)
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'spline')
data %>% ggplot(aes(Year, Rail_tracks_KM)) + geom_line()
data %>% ggplot(aes(Year, Total_freight_loaded_and_unloaded)) + geom_line()
dat
data$Total_freight_loaded_and_unloaded <- na_interpolation(data$Total_freight_loaded_and_unloaded, option = 'spline')
data <- data %>%
mutate(livestock_heads = Pigs_heads + Bovine_heads) %>%
select(!c(Pigs_heads, Bovine_heads))
data <- data %>%
mutate(res_capacity = hydro_capacity + geothermal_capacity +
wind_capacity + solar_capacity + biofuels_capacity +
biogas_capacity + waste_capacity) %>%
select(!c(hydro_capacity, geothermal_capacity,
wind_capacity, solar_capacity, biofuels_capacity,
biogas_capacity, waste_capacity))
str(data)
#ADF test
#H0: time series is not stationary
adf.test(data$net_greenhouse_pc) #dependent variable is not stationary
data2 <- data %>% mutate_at(c('net_greenhouse_pc'), ~(scale(.) %>% as.vector))
View(data2)
data <- data %>% mutate_at(c('net_greenhouse_pc'), ~(scale(.) %>% as.vector))
plot(x = data$Year, y = data$net_greenhouse_pc, type = "l" )
par(mfrow = c(1, 1))
plot(x = data$Year, y = data$net_greenhouse_pc, type = "l" )
#ADF test
#H0: time series is not stationary
adf.test(data$net_greenhouse_pc) #dependent variable is not stationary
nsdiffs(data$net_greenhouse_pc)
library(forecast)
nsdiffs(data$net_greenhouse_pc)
ndiffs(data$net_greenhouse_pc)
data2 <- data %>% mutate(net_greenhouse_pc = diff(net_greenhouse_pc, differences = 1))
View(data)
data2 <- data %>% mutate(x = diff(net_greenhouse_pc, differences = 1))
test <- diff(data$net_greenhouse_pc, differences = 1)
plot(x)
plot(x, type = 'line')
plot(test, type = 'line')
adf.test(test)
test <- diff(data$net_greenhouse_pc, differences = 2)
plot(test, type = 'line') #visual check
adf.test(test)
ndiffs(data$net_greenhouse_pc) #how many diffs should we take?
rm(test, x)
st_data$net_greenhouse_pc <- diff(data$net_greenhouse_pc, differences = 1)
#Test for stationarity - ADF test
#H0: time series is not stationary
adf.test(data$net_greenhouse_pc) #dependent variable is not stationary
ndiffs(data$net_greenhouse_pc) #how many diffs should we take?
rm(data2)
ndiffs(data$net_greenhouse_pc) #how many diffs should we take?
net_greenhouse_pc <- diff(data$net_greenhouse_pc, differences = 1) #first differentiation
adf.test(net_greenhouse_pc)
net_greenhouse_pc <- diff(data$net_greenhouse_pc, differences = 1) #second differentiation
adf.test(test)
adf.test(net_greenhouse_pc)
net_greenhouse_pc <- diff(net_greenhouse_pc, differences = 1) #second differentiation
adf.test(net_greenhouse_pc)
plot(test, type = 'line') #visual check
plot(net_greenhouse_pc, type = 'line') #visual check
plot(net_greenhouse_pc) #visual check
