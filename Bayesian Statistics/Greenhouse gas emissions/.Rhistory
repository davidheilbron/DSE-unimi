iVbeta <- diag(tmp, nrow = k*n, ncol = k*n)
# Create the lagged variable
tmpY    <- rbind(as.matrix(Y0[(nrow(Y0) - p + 1):nrow(Y0),]), Y)
X_tilde <- matrix(0, nrow = T, ncol = (n + m)*p)
for (i in 1:p){
X_tilde[,((i - 1)*(n+m) + 1):(i*(n+m))] <- tmpY[(p - i + 1):(T - i),]
}
mlag_1 <- Yraw[4:nrow(Yraw)-1,]
View(mlag_1)
mlag_1 <- Yraw[5:nrow(Yraw)-1,]
mlag_2 <- Yraw[4:nrow(Yraw)-2,]
mlag_2 <- Yraw[4:nrow(Yraw)-1,]
mlag_2 <- Yraw[4:nrow(Yraw)-2,]
mlag_2 <- Yraw[4:(nrow(Yraw)-2),]
mlag_1 <- Yraw[4:(nrow(Yraw)-1),]
mlag_2 <- Yraw[3:(nrow(Yraw)-2),]
X_tilde <- cbind(mlag_1, mlag_2)
View(X_tilde)
X_tilde <- cbind(rep(1,T), X_tilde)
SURform2 <- function(X, n) {
repX <- kronecker(X, matrix(1, ncol = n))
r <- nrow(X)
c <- ncol(X)
idi <- kronecker(1:(r*n), matrix(1, ncol = c))
idj <- matrix(rep(1:(n*c), each = r), ncol = 1)
X_out <- sparseMatrix(i = idi, j = idj, x = c(repX))
return(X_out)
}
X       <- SURform2(X_tilde,n)
View(X)
X       <- SURform2(X_tilde,(n+m))
View(X)
X@i
X@p
X@x
X@i
X@p
# Storage of variables
store_Sig  <- array(0, dim=c(nsim,(n+m),(n+m)))
store_beta <- array(0, dim=c(nsim,k*n))
store_yIR  <- matrix(0, nrow=n_hz, ncol=(n+m)
store_yIR  <- matrix(0, nrow=n_hz, ncol=(n+m))
store_yIR  <- matrix(0, nrow = n_hz, ncol = (n + m))
# Initialize the chain
beta <- solve(t(X) %*% X) %*% t(X) %*% y
class(X)
# Initialize the chain
beta <- solve(t(X@x) %*% X@x) %*% t(X@x) %*% y
copy_X <- X
X <- as.matrix(X)
View(X)
# Initialize the chain
beta <- solve(t(X) %*% X) %*% t(X) %*% y
t(X) %*% X
solve(t(X) %*% X)
View(X)
X
View(X_tilde)
View(X)
X <- SURform2(X_tilde,n)
X <- as.matrix(X)
# Initialize the chain
beta <- solve(t(X) %*% X) %*% t(X) %*% y
X <- as.matrix(X)
# Initialize the chain
beta <- solve(t(X) %*% X) %*% t(X) %*% y
det(X)
rank(qr(X))
View(X)
qr(X)
solve(t(X) %*% X)
t(X)
t(X) %*% X
qr(t(X) %*% X)
# Initialize the chain
beta <- matrix(nrow=13, ncol=1, data=1)
e    <- matrix(y - X %*% beta, n, T)
Sig  <- t(e) %*% e/T
iSig <- solve(Sig)
e    <- matrix(nrow=13, ncol=27, data=1)
Sig  <- t(e) %*% e/T
iSig <- solve(Sig)
e    <- matrix(nrow=13, ncol=27, data= rnorm(1, mean=1, sd=1))
Sig  <- t(e) %*% e/T
iSig <- solve(Sig)
e    <- matrix(nrow=13, ncol=27, data= rnorm(2, mean=1, sd=1))
e    <- matrix(nrow=13, ncol=27, data= rnorm(351, mean=1, sd=1))
Sig  <- t(e) %*% e/T
iSig <- solve(Sig)
bayes_data <- scale(bayes_data)
#Load data
bayes_data <- read.csv("bayes_data.csv")
bayes_data <- apply(bayes_data, MARGIN = 2, FUN=scale())
bayes_data <- apply(bayes_data, MARGIN = 2, FUN = scale)
Y_tmp <- bayes_data
Yraw  <- as.matrix(Y_tmp[,-1])
Dates <- Y_tmp[,1]
Y0 <- as.matrix(Yraw[1:4,1]) # save the first 4 obs as the initial conditions
Y  <- as.matrix(Yraw[5:nrow(Yraw),1])
T <- nrow(Y) #number of observations
n <- ncol(Y) #number of endogenous features
m <- 5 #number of exogenous features
y <- as.vector(t(Y)) #transform the features matrix into a single vector
k <- n*p + m*p + 1 # number of coefficients in each equation
n_hz  <- 5 # number of horizons for IRs
# Prior hyperparameters
nu0 <- 2*(m + n) #ask the professor
S0 <- diag(m + n)
beta0 <- numeric(n*k)
# precision for coefficients = 1; for intercepts = 1/10
tmp <- rep(1,k*n)
tmp[seq(from = 1,to = k*n, by = k)] <- 1/10
iVbeta <- diag(tmp, nrow = k*n, ncol = k*n)
# Create the lagged variable
tmpY    <- rbind(as.matrix(Y0[(nrow(Y0) - p + 1):nrow(Y0),]), Y)
X_tilde <- matrix(0, nrow = T, ncol = (n + m)*p)
mlag_1 <- Yraw[4:(nrow(Yraw)-1),]
mlag_2 <- Yraw[3:(nrow(Yraw)-2),]
X_tilde <- cbind(mlag_1, mlag_2)
X_tilde <- cbind(rep(1,T), X_tilde)
SURform2 <- function(X, n) {
repX <- kronecker(X, matrix(1, ncol = n))
r <- nrow(X)
c <- ncol(X)
idi <- kronecker(1:(r*n), matrix(1, ncol = c))
idj <- matrix(rep(1:(n*c), each = r), ncol = 1)
X_out <- sparseMatrix(i = idi, j = idj, x = c(repX))
return(X_out)
}
X <- SURform2(X_tilde,n)
copy_X <- X
X <- as.matrix(X)
rank(qr(X))
qr(X)
# Storage of variables
store_Sig  <- array(0, dim=c(nsim,(n+m),(n+m)))
store_beta <- array(0, dim=c(nsim,k*n))
store_yIR  <- matrix(0, nrow = n_hz, ncol = (n + m))
# Initialize the chain
beta <- solve(t(X) %*% X) %*% t(X) %*% y
e    <- matrix(y - X %*% beta, n, T)
Sig  <- t(e) %*% e/T
iSig <- solve(Sig)
# Initialize the chain
beta <- matrix(nrow=13, ncol=1, data=1)
e    <- matrix(nrow=13, ncol=27, data= rnorm(351, mean=1, sd=1))
e    <- matrix(y - X %*% beta, n, T)
iSig <- matrix(nrow=13, ncol=27, data= rnorm(351, mean=1, sd=1))
## Gibbs sampler
tic <- Sys.time()
for (isim in 1:(nsim + burnin)) {
# Posterior of beta \sim Normal
XiSig    <- t(X) %*% kronecker(diag(T),iSig)
XiSigX   <- XiSig %*% X
Kbeta    <- iVbeta + XiSigX # posterior variance
beta_hat <- solve(Kbeta) %*% (iVbeta %*% beta0 + XiSig %*% y) # posterior mean
beta     <- beta_hat + chol2inv(chol(Kbeta)) %*% rnorm(n*k,0,1)
# posterior of Sigma \sim iWishart
e    <- matrix(y - X %*% beta, n, T)
Sig  <- riwish(nu0 + T, S0 + t(e) %*% e)
iSig <- solve(Sig)
# Count the number of iterations
if (isim %% 1000 == 0) {
elapsed_time <- Sys.time() - start_time
print(paste("Iteration:", isim, "of", nsim + burnin, ". Elapsed time is", elapsed_time, "seconds."))
}
#Store the parameters
if (isim > burnin) {
isave <- isim - burnin
store_beta[isave,] <- beta
store_Sig[isave,,] <- Sig
# Compute impulse-responses
CSig <- chol(Sig, lower = TRUE)
# 100 basis pts rather than 1 std. dev.
shock <- c(0, 0, 1) / CSig[n, n]
yIR <- construct_IR(beta, Sig, n_hz, shock)
store_yIR <- store_yIR + yIR
}
data <- read_excel("data.xlsx", sheet = 'Data')
#Turn character features to numeric
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Head_sheep <- as.numeric(data$Head_sheep)
data$Head_goat <- as.numeric(data$Head_goat)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
str(data)
raw <- data
#Data imputation
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'spline')
data %>% ggplot(aes(Year, Rail_tracks_KM)) + geom_line()
data %>% ggplot(aes(Year, Total_freight_loaded_and_unloaded)) + geom_line()
data$Total_freight_loaded_and_unloaded <- na_interpolation(data$Total_freight_loaded_and_unloaded, option = 'spline')
data %>% ggplot(aes(Year, Chicken_heads)) + geom_line()
data$Chicken_heads <- na_interpolation(data$Chicken_heads, option = 'spline')
data %>% ggplot(aes(Year, Chicken_heads)) + geom_line()
data %>% ggplot(aes(Year, Turkeys_heads)) + geom_line()
data$Turkeys_heads <- na_interpolation(data$Turkeys_heads, option = 'spline')
data %>% ggplot(aes(Year, Turkeys_heads)) + geom_line()
data <- data %>%
mutate(livestock_heads = Pigs_heads + Head_sheep + Head_goat +
Chicken_heads + Turkeys_heads + Cattle_heads + Buffalo_head) %>%
select(!c(Pigs_heads, Head_goat,Head_sheep, Chicken_heads,Turkeys_heads,Cattle_heads,Buffalo_head))
data <- data %>%
mutate(res_capacity = hydro_capacity + geothermal_capacity +
wind_capacity + solar_capacity + biofuels_capacity +
biogas_capacity + waste_capacity) %>%
select(!c(hydro_capacity, geothermal_capacity,
wind_capacity, solar_capacity, biofuels_capacity,
biogas_capacity, waste_capacity))
bayes <- data %>% select(Year, net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply)
bayes_sca <- as.data.frame(apply(bayes, MARGIN = 2, scale)) #Apply second differences
write.csv(bayes_sca, 'bayes_data.csv')
bayes_d2 <- diff(bayes, differences = 2)
bayes_d2 <- as.data.frame(apply(bayes, MARGIN = 2, diff(differences = 2)))
net_greenhouse_pc <- diff(bayes$net_greenhouse_pc, differences = 2)
industrial_production <- diff(bayes$industrial_production, differences = 2)
naturalgas_imports <- diff(bayes$naturalgas_imports, differences = 2)
total_energy_supply <- diff(bayes$total_energy_supply, differences = 2)
bayes <- data %>% select(Year, net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply)
View(bayes)
bayes <- data %>% select(net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply)
bayes <- select(net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply)
bayes <- cbind(net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply)
bayes <- as.data.frame(cbind(net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply))
View(bayes)
bayes_sca <- as.data.frame(apply(bayes, MARGIN = 2, scale)) #Apply scaling
write.csv(bayes_sca, 'bayes_data.csv')
#Load data
bayes_data <- read.csv("bayes_data.csv")
bayes_data <- apply(bayes_data, MARGIN = 2, FUN = scale)
set.seed(100)
#Load data
bayes_data <- read.csv("bayes_data.csv")
View(bayes_data)
set.seed(100)
# Set the lag of the VAR
p <- 2
# Gibbs sampler iterations
nsim   <- 20000
burnin <- 1000
Y_tmp <- bayes_data
Yraw  <- as.matrix(Y_tmp[,-1])
Dates <- Y_tmp[,1]
Y0 <- as.matrix(Yraw[1:4,1]) # save the first 4 obs as the initial conditions
Y  <- as.matrix(Yraw[5:nrow(Yraw),1])
T <- nrow(Y) #number of observations
n <- ncol(Y) #number of endogenous features
m <- 5 #number of exogenous features
y <- as.vector(t(Y)) #transform the features matrix into a single vector
k <- n*p + m*p + 1 # number of coefficients in each equation
n_hz  <- 5 # number of horizons for IRs
# Prior hyperparameters
nu0 <- 2*(m + n) #ask the professor
S0 <- diag(m + n)
beta0 <- numeric(n*k)
# precision for coefficients = 1; for intercepts = 1/10
tmp <- rep(1,k*n)
tmp[seq(from = 1,to = k*n, by = k)] <- 1/10
iVbeta <- diag(tmp, nrow = k*n, ncol = k*n)
# Create the lagged variable
tmpY    <- rbind(as.matrix(Y0[(nrow(Y0) - p + 1):nrow(Y0),]), Y)
X_tilde <- matrix(0, nrow = T, ncol = (n + m)*p)
mlag_1 <- Yraw[4:(nrow(Yraw)-1),]
mlag_2 <- Yraw[3:(nrow(Yraw)-2),]
X_tilde <- cbind(mlag_1, mlag_2)
X_tilde <- cbind(rep(1,T), X_tilde)
SURform2 <- function(X, n) {
repX <- kronecker(X, matrix(1, ncol = n))
r <- nrow(X)
c <- ncol(X)
idi <- kronecker(1:(r*n), matrix(1, ncol = c))
idj <- matrix(rep(1:(n*c), each = r), ncol = 1)
X_out <- sparseMatrix(i = idi, j = idj, x = c(repX))
return(X_out)
}
X <- SURform2(X_tilde,n)
X <- as.matrix(X)
rank(qr(X))
qr(X)
# Storage of variables
store_Sig  <- array(0, dim=c(nsim,(n+m),(n+m)))
store_beta <- array(0, dim=c(nsim,k*n))
store_yIR  <- matrix(0, nrow = n_hz, ncol = (n + m))
# Initialize the chain
beta <- solve(t(X) %*% X) %*% t(X) %*% y
e    <- matrix(y - X %*% beta, n, T)
Sig  <- t(e) %*% e/T
iSig <- solve(Sig)
t(e)
e/T
t(e) %*% e/T
iSig <- solve(Sig)
View(e)
e    <- matrix(y - X %*% beta, (n+m), T)
Sig  <- t(e) %*% e/T
iSig <- solve(Sig)
View(bayes_data)
#Prepare the data
temp <- gen_var(data, p = 2, deterministic = "const")
data <- ts(data)
data <- read.csv("bayes_data.csv")
data <- ts(data)
View(data)
data <- read.csv("bayes_data.csv")
data <- ts(data[,-1])
#Prepare the data
temp <- gen_var(data, p = 2, deterministic = "const")
y <- temp$Y
x <- temp$Z
View(temp)
#Prepare the data
temp <- gen_var(data, p = 2, deterministic = "const")
y <- temp$Y
x <- temp$Z
k <- NROW(y)
tt <- ncol(y)
z <- kronecker(t(x), diag(1, k))
m <- ncol(z)
temp$Y
#Prepare the data
temp <- gen_var(data, p = 2, deterministic = "const")
y <- temp$data$Y
x <- temp$data$Z
k <- NROW(y)
tt <- ncol(y)
z <- kronecker(t(x), diag(1, k))
m <- ncol(z)
#Specify the priors
mu_prior <- matrix(0, m) # Prior mean
v_i_prior <- diag(1, m) # Prior variance
diag(v_i_prior)[m - k + 1:k] <- 1 / 10 # Deterministics
df_prior <- k + 3
df_post <- tt + df_prior
scale_prior = diag(1, k)
#Initial values
ols <- tcrossprod(y, x) %*% solve(tcrossprod(x))
df_prior <- k + 4
df_post <- tt + df_prior
scale_prior = diag(1, k)
#Initial values
ols <- tcrossprod(y, x) %*% solve(tcrossprod(x))
tcrossprod(y, x)
solve(tcrossprod(x))
View(x)
data <- read.csv("bayes_data.csv")
data <- ts(data[,-2])
data <- read.csv("bayes_data.csv")
data <- ts(data[,-c(1,2)])
set.seed(100)
#Prepare the data
temp <- gen_var(data, p = 2, deterministic = "const")
y <- temp$data$Y
x <- temp$data$Z
k <- NROW(y)
tt <- ncol(y)
z <- kronecker(t(x), diag(1, k))
m <- ncol(z)
#Specify the priors
mu_prior <- matrix(0, m) # Prior mean
v_i_prior <- diag(1, m) # Prior variance
diag(v_i_prior)[m - k + 1:k] <- 1 / 10 # Deterministics
df_prior <- k + 4
df_post <- tt + df_prior
scale_prior = diag(1, k)
#Initial values
ols <- tcrossprod(y, x) %*% solve(tcrossprod(x))
epsilon <- y - ols %*% x
sigma <- tcrossprod(epsilon) / tt
#Load data
bayes_data <- read.csv("bayes_data.csv")
data <- read.csv("bayes_data.csv")
View(bayes_data)
lapply(data, MARGIN=2, FUN=adf.test())
adf.test(data$net_greenhouse_pc)
adf.test(data$GDP.pc)
adf.test(data$res_cap)
adf.test(data$Cattle_heads)
net_greenhouse_pc <- diff(data$net_greenhouse_pc , differences = 1)
GDP.pc <- diff(data$GDP.pc , differences = 1)
res_cap <- diff(data$res_cap , differences = 1)
Cattle_heads <- diff(data$Cattle_heads , differences = 1)
#Test again
adf.test(net_greenhouse_pc)
adf.test(GDP.pc)
adf.test(res_cap)
adf.test(Cattle_heads)
net_greenhouse_pc <- diff(data$net_greenhouse_pc , differences = 1)
GDP.pc <- diff(data$GDP.pc , differences = 1)
res_cap <- diff(data$res_cap , differences = 1)
Cattle_heads <- diff(data$Cattle_heads , differences = 1)
#Test again
adf.test(net_greenhouse_pc)
adf.test(GDP.pc)
adf.test(res_cap)
adf.test(Cattle_heads)
data <- read.csv("bayes_data.csv")
adf.test(data$net_greenhouse_pc)
adf.test(data$GDP.pc)
adf.test(data$res_cap)
adf.test(data$Cattle_heads)
net_greenhouse_pc <- diff(data$net_greenhouse_pc , differences = 2)
GDP.pc <- diff(data$GDP.pc , differences = 2)
res_cap <- diff(data$res_cap , differences = 2)
Cattle_heads <- diff(data$Cattle_heads , differences = 2)
adf.test(net_greenhouse_pc)
adf.test(GDP.pc)
adf.test(res_cap)
adf.test(Cattle_heads)
data <- lapply(data, MARGIN=2, FUN=ln())
data <- apply(data, MARGIN=2, log)
data <- data[,-1]
#Check for stationarity
adf.test(data$net_greenhouse_pc)
data
#Check for stationarity
adf.test(data$net_greenhouse_pc)
data <- data.frame(data)
data <- read.csv("bayes_data.csv")
data <- apply(data, MARGIN=2, log)
data <- data[,-1]
data <- data.frame(data)
#Check for stationarity
adf.test(data$net_greenhouse_pc)
adf.test(data$GDP.pc)
adf.test(data$res_cap)
adf.test(data$Cattle_heads)
#Take first differences
net_greenhouse_pc <- diff(data$net_greenhouse_pc , differences = 2)
GDP.pc <- diff(data$GDP.pc , differences = 2)
res_cap <- diff(data$res_cap , differences = 2)
Cattle_heads <- diff(data$Cattle_heads , differences = 2)
#Test again
adf.test(net_greenhouse_pc)
adf.test(GDP.pc)
adf.test(res_cap)
adf.test(Cattle_heads)
data <- cbind(net_greenhouse_pc, Cattle_heads)
set.seed(100)
#Prepare the data
temp <- gen_var(data, p = 2, deterministic = "const")
data <- ts(data, frequency = 1)
set.seed(100)
#Prepare the data
temp <- gen_var(data, p = 2, deterministic = "const")
y <- temp$data$Y
x <- temp$data$Z
k <- NROW(y)
tt <- ncol(y)
z <- kronecker(t(x), diag(1, k))
m <- ncol(z)
#Specify the priors
mu_prior <- matrix(0, m) # Prior mean
v_i_prior <- diag(1, m) # Prior variance
diag(v_i_prior)[m - k + 1:k] <- 1 / 10 # Deterministics
df_prior <- k + 4
df_post <- tt + df_prior
scale_prior = diag(1, k)
#Initial values
ols <- tcrossprod(y, x) %*% solve(tcrossprod(x))
epsilon <- y - ols %*% x
sigma <- tcrossprod(epsilon) / tt
tcrossprod(x)
solve(tcrossprod(x))
data <- read_excel("data.xlsx", sheet = 'Data')
#Turn character features to numeric
data$Pigs_heads <- as.numeric(data$Pigs_heads)
data$Head_sheep <- as.numeric(data$Head_sheep)
data$Head_goat <- as.numeric(data$Head_goat)
data$Share_of_land_under_permanent_crops <- as.numeric(data$Share_of_land_under_permanent_crops)
data$Fertilizer_used_per_area_of_cropland <- as.numeric(data$Fertilizer_used_per_area_of_cropland)
data$Share_in_land_area_Forest_Land <- as.numeric(data$Share_in_land_area_Forest_Land)
str(data)
data$Rail_tracks_KM <- na_interpolation(data$Rail_tracks_KM, option = 'spline')
data %>% ggplot(aes(Year, Rail_tracks_KM)) + geom_line()
data %>% ggplot(aes(Year, Total_freight_loaded_and_unloaded)) + geom_line()
data$Total_freight_loaded_and_unloaded <- na_interpolation(data$Total_freight_loaded_and_unloaded, option = 'spline')
data %>% ggplot(aes(Year, Chicken_heads)) + geom_line()
data$Chicken_heads <- na_interpolation(data$Chicken_heads, option = 'spline')
data %>% ggplot(aes(Year, Chicken_heads)) + geom_line()
data %>% ggplot(aes(Year, Turkeys_heads)) + geom_line()
data$Turkeys_heads <- na_interpolation(data$Turkeys_heads, option = 'spline')
data %>% ggplot(aes(Year, Turkeys_heads)) + geom_line()
#Merge RES capacity and Livestock features
data <- data %>%
mutate(livestock_heads = Pigs_heads + Head_sheep + Head_goat +
Chicken_heads + Turkeys_heads + Cattle_heads + Buffalo_head) %>%
select(!c(Pigs_heads, Head_goat,Head_sheep, Chicken_heads,Turkeys_heads,Cattle_heads,Buffalo_head))
data <- data %>%
mutate(res_capacity = hydro_capacity + geothermal_capacity +
wind_capacity + solar_capacity + biofuels_capacity +
biogas_capacity + waste_capacity) %>%
select(!c(hydro_capacity, geothermal_capacity,
wind_capacity, solar_capacity, biofuels_capacity,
biogas_capacity, waste_capacity))
bayes <- data %>% select(Year, net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply)
net_greenhouse_pc <- diff(bayes$net_greenhouse_pc, differences = 2)
industrial_production <- diff(bayes$industrial_production, differences = 2)
naturalgas_imports <- diff(bayes$naturalgas_imports, differences = 2)
total_energy_supply <- diff(bayes$total_energy_supply, differences = 2)
bayes <- as.data.frame(cbind(net_greenhouse_pc, industrial_production,
naturalgas_imports, total_energy_supply))
head(bayes) #check head
bayes_sca <- as.data.frame(apply(bayes, MARGIN = 2, scale)) #Apply scaling
write.csv(bayes_sca, 'bayes_data.csv')
