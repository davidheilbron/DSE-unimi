---
title: "BVAR TS model"
output: html_document
date: "2023-05-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Libraries

```{r libraries}
library(bvartools)
library(tidyverse)
library(readxl)
library(lubridate)
library(zoo)
library(xts)
library(dplyr)
library(data.table)
library(imputeTS)
library(ggplot2)
library(MTS)
library(tseries)
library(forecast)
library(bvartools)
library(coda)
library(spam)
library(vars)
```

First model to be tested: ...

```{r check data}
bayes <- read.csv("bayes_data_24.csv")
bayes <- bayes[,-1]
head(bayes) #check head
bayes_ts <- as.ts(bayes)
plot(bayes_ts)
summary(bayes_ts)
```


## Model selection

```{r model selection}
VARselect(bayes_ts, lag.max = 4,type = "const") 
bmodel <- gen_var(bayes_ts, p = 1, deterministic = "const")
y <- t(bmodel$data$Y)
x <- t(bmodel$data$Z)
```

# OLS estimation

```{r frequentist estimation}
beta_ols <- tcrossprod(y, x) %*% solve(tcrossprod(x)) # Calculate estimates
round(beta_ols, 3) # Round estimates and print

mu_ols <- y - beta_ols %*% x
mu_sigma_ols <- tcrossprod(mu_ols) / (ncol(y) - nrow(x))
round(mu_sigma_ols, 2)
```

# Bayesian estimation

```{r bayesian estimation}

set.seed(1234567)
iter <- 20000 # Number of iterations of the Gibbs sampler
burnin <- 2000 # Number of burn-in draws
store <- iter - burnin

t <- ncol(y) # Number of observations
k <- nrow(y) # Number of endogenous variables
m <- k * nrow(x) # Number of estimated coefficients
```

```{r set priors}
a_mu_prior <- matrix(0, m) # Vector of prior parameter means
a_v_i_prior <- diag(1, m) # Inverse of the prior covariance matrix

u_sigma_df_prior <- 2*k # Prior degrees of freedom
u_sigma_scale_prior <- diag(1, k) # Prior covariance matrix
u_sigma_df_post <- t + u_sigma_df_prior # Posterior degrees of freedom
```

```{r Initial Values}
u_sigma_i <- solve(mu_sigma_ols)

# Data containers for posterior draws
draws_a <- matrix(NA, m, store)
draws_sigma <- matrix(NA, k * k, store)
```

```{r Start Gibbs sampler}
for (draw in 1:iter) {
  # Draw conditional mean parameters
  a <- post_normal(y, x, u_sigma_i, a_mu_prior, a_v_i_prior)
  
  # Draw variance-covariance matrix
  u <- y - matrix(a, k) %*% x # Obtain residuals
  u_sigma_scale_post <- solve(u_sigma_scale_prior + tcrossprod(u))
  u_sigma_i <- matrix(rWishart(1, u_sigma_df_post, u_sigma_scale_post)[,, 1], k)
  u_sigma <- solve(u_sigma_i) # Invert Sigma_i to obtain Sigma
  
  # Store draws
  if (draw > burnin) {
    draws_a[, draw - burnin] <- a
    draws_sigma[, draw - burnin] <- u_sigma
  }
}
```

```{r Gibss sampler results}

A <- rowMeans(draws_a) # Obtain means for every row
A <- matrix(A, k) # Transform mean vector into a matrix
A <- round(A, 3) # Round values
dimnames(A) <- list(dimnames(y)[[1]], dimnames(x)[[1]]) # Rename matrix dimensions

A # Print

Sigma <- rowMeans(draws_sigma) # Obtain means for every row
Sigma <- matrix(Sigma, k) # Transform mean vector into a matrix
Sigma <- round(Sigma, 2) # Round values
dimnames(Sigma) <- list(dimnames(y)[[1]], dimnames(y)[[1]]) # Rename matrix dimensions

Sigma # Print
```

```{r BVAR object}
bvar_model <- bvar(y = bmodel$data$Y, x = bmodel$data$Z, A = draws_a[1:9,],
                 C = draws_a[10:12, ], Sigma = draws_sigma)
#bvar_model <- thin.bvar(bvar_model, thin = 2)
summary(bvar_model)

```

```{r Chain analysis}
str(draws_a)
for (i in 1:nrow(draws_a)){
  par(mfrow = c(1, 2))
  ts.plot(draws_a[i,], 
          xlab = 'Number of iterations', 
          ylab = "Coefficient value", 
          main = paste0("Chain for coefficient ", i))
  acf(draws_a[i,], main = paste0("ACF for coefficient ", i))
}
plot(bvar_model)
```

```{r IRF Analysis}
OIR <- bvartools::irf(bvar_model, impulse = "oil_imports_1", response = "net_greenhouse_pc_1", n.ahead = 5, type = "oir")
plot(OIR, main = "Orthogonalised Impulse Response", xlab = "Period", ylab = "Response")

GIR <- bvartools::irf(bvar_model, impulse = "oil_imports_1", response = "net_greenhouse_pc_1", n.ahead = 5, type = "gir")
plot(GIR, main = "Generalised Impulse Response", xlab = "Period", ylab = "Response")
```

```{r Error Variance Decomposition}
bvar_fevd_oir <- bvartools::fevd(bvar_model, response = "net_greenhouse_pc_1")
plot(bvar_fevd_oir, main = "OIR-based FEVD of Net Greenhouse gas emissions per capita")

bvar_fevd_gir <- bvartools::fevd(bvar_model, response = "net_greenhouse_pc_1", type = "gir")
plot(bvar_fevd_gir, main = "GIR-based FEVD of Net Greenhouse gas emissions per capita")
```
